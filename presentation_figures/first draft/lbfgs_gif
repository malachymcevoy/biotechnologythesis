using Optim
using Plots

# === Define the Rosenbrock Function ===
rosenbrock(u) = (1.0 - u[1])^2 + 100.0 * (u[2] - u[1]^2)^2

# === Initial Guess ===
x0 = [0.0, 0.0]  # Initial guess of [0.0, 0.0] as requested

# === Run multiple optimizations with increasing max_iterations to capture the path ===
max_iterations = 20  # Adjust this based on how many steps you want to capture
all_points = [copy(x0)]  # Start with initial guess

for i in 1:max_iterations
    # Run optimization with limited iterations
    result = optimize(rosenbrock, x0, LBFGS(), 
                     Optim.Options(iterations=i, store_trace=false))
    
    # Get the final position after i iterations
    final_point = Optim.minimizer(result)
    push!(all_points, copy(final_point))
end

# Extract x and y coordinates
xs = [p[1] for p in all_points]
ys = [p[2] for p in all_points]

# === Create a grid for contour plot ===
grid_x = range(-0.5, 1.5, length=100)
grid_y = range(-0.5, 1.5, length=100)

# Compute the Rosenbrock function values for each grid point
Z = [rosenbrock([xi, yi]) for xi in grid_x, yi in grid_y]

# Create logarithmic values for better visualization
log_Z = log10.(Z .+ 1)  # Adding 1 to avoid log(0)

# === Generate GIF of LBFGS Optimization Path ===
anim = @animate for i in 1:length(xs)
    # Create contour plot
    p = contour(grid_x, grid_y, log_Z,
         xlabel="x", ylabel="y", levels=20,
         linewidth=1.5, c=:viridis, 
         title="LBFGS Optimization of Rosenbrock Function\nIteration $i")
    
    # Plot the optimization path so far
    plot!(xs[1:i], ys[1:i], color=:red, linewidth=2, label="")
    scatter!([xs[i]], [ys[i]], color=:red, label="Current Position", ms=4)
    
    # Mark the global minimum at (1,1)
    scatter!([1.0], [1.0], color=:green, label="Global Minimum", ms=4)
end every 1

# Save the animation as a GIF
gif(anim, "rosenbrock_lbfgs.gif", fps=5)